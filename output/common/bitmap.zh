/**
*	This namespace contains functions used for handling bitmap
*	allocation, for freeing bitmaps, and for determining if 
*	bitmaps are available for use. 
*/
namespace bitmaps
{
	const int NUM_BITMAPS = 256 - 6; //6 system bitmaps take up pointer space, and won't be used!
	untyped allocated_bitmaps[NUM_BITMAPS * 2]; /**< This array holds pointers of bitmaps in odd indexes, with their state in the even index prior */
	enum BitState
	{
		STATE_FREE,
		STATE_INUSE,
		STATE_FREEING
		STATE_LOCKED
	};
	/**
	*	Acquires a bitmap, trying to find freed bitmaps first.
	*	Returns the pointer to the bitmap.
	*	@param h the height of the bitmap to attempt to acquire
	*	@param w the width of the bitmap to attempt to acquire
	*	@see release()
	*/
	bitmap acquire(int w, int h)
	{
		bitmap acquire(w,h,0);
	}
	/**
	*	Acquires a bitmap, trying to find freed bitmaps first.
	*	Returns the pointer to the bitmap.
	*	@param h the height of the bitmap to attempt to acquire
	*	@param w the width of the bitmap to attempt to acquire
	*	@param layer the layer (draw timing to use for ->Create calls
	*	@see release()
	*/
	bitmap acquire(int w, int h, int layer)
	{
		bitmap temp;
		if ( Game->FFRules[qr_OLDCREATEBITMAP_ARGS] )
		{
			int ww = h;
			h = w;
			w = ww; 
		}
		//Find an index not in use
		for ( int q = 0; q < NUM_BITMAPS*2; q+=2 )
		{
			unless ( allocated_bitmaps[q] )
			{
				if((<bitmap>allocated_bitmaps[q+1])->isAllocated())
				{
					temp = allocated_bitmaps[q+1];
					temp->Create(layer, w,h);
				}
				else
				{
					temp = Game->CreateBitmap(w,h);
					allocated_bitmaps[q+1] = temp;
				}
				allocated_bitmaps[q] = STATE_INUSE;
				return temp;
			}
		}
		printf("Could not allocate a bitmap. All bitmaps are in use!\n");
		return NULL;
	}
	/*!
	*	Marks a bitmap as being released, and clears it.
	*	@param b a bitmap datatype of the bitmap pointer
	*/
	bool release(bitmap b)
	{
		return release(b, 0);
	}
	/*!
	*	Locks a bitmap so that it cannot be released. 
	*	@param b a bitmap datatype of the bitmap pointer
	*/
	bool lock(bitmap b)
	{
		for ( int q = 0; q < NUM_BITMAPS*2; q+=2 )
		{
			if ( allocated_bitmaps[q+1] == b )
			{
				allocated_bitmaps[q] = STATE_LOCKED;
				return true;
			}
		}
		return false;
	}
	/*!
	*	Unlocks a bitmap so that it cannot be released. 
	*	@param b a bitmap datatype of the bitmap pointer
	*	@param free determines if it is unlocked to an INUSE (true) state, or a FREEING (false) state.
	*/
	bool unlock(bitmap b, bool free)
	{
		for ( int q = 0; q < NUM_BITMAPS*2; q+=2 )
		{
			if ( allocated_bitmaps[q+1] == b )
			{
				allocated_bitmaps[q] = ( free ) ? STATE_INUSE : STATE_FREEING;
				return true;
			}
		}
		return false;
	}
	/*!
	*	Marks a bitmap as being released, and clears it.
	*	@param b a bitmap datatype of the bitmap pointer
	*	@param layer an ineger datatype of the bitmap layer to clear
	*/
	bool release(bitmap b, int layer)
	{
		for ( int q = 0; q < NUM_BITMAPS*2; q+=2 )
		{
			if ( allocated_bitmaps[q+1] == b )
			{
				unless ( allocated_bitmaps[q] == STATE_LOCKED )
				{
					allocated_bitmaps[q] = STATE_FREEING;
					b->Clear(layer);
					return true;
				}
			}
		}
		return false;
	}
	/*!
	*	Returns if a bitmap <b> is allocated.
	*	@param b a bitmap datatype of the bitmap pointer
	*/
	bool inuse(bitmap b)
	{
		for ( int q = 0; q < NUM_BITMAPS*2; q+=2 )
		{
			if ( allocated_bitmaps[q+1] == b )
			{
				return allocated_bitmaps[q] != STATE_FREE;
			}
		}
		return false;
	}
	/*!
	*	Returns if a bitmap allocation slot <b> is free. 
	*	@param b a bitmap datatype of the bitmap pointer
	*/
	bool freed(bitmap b)
	{
		for ( int q = 0; q < NUM_BITMAPS*2; q+=2 )
		{
			if ( allocated_bitmaps[q+1] == b )
			{
				return allocated_bitmaps[q] == STATE_FREE;
			}
		}
		return false;
	}
	/*!
	*	Call at the beginning of each frame in the global active
	* 	to update / poll freed bitmaps so that draws do not overwrite them.
	*/
	void updatefreed()
	{
		for ( int q = 0; q < NUM_BITMAPS*2; q+=2 )
		{
			if ( allocated_bitmaps[q] == STATE_FREEING )
			{
				allocated_bitmaps[q] = STATE_FREE;
			}
		}
	}
	/*!
	*	Call in global onLaunch, or onSaveLoad
	*	Refreshes the database of stale pointers
	*/
	void refresh_pointers()
	{
		for ( int q = 0; q < NUM_BITMAPS*2; q+=2 )
		{
			unless( (<bitmap>allocated_bitmaps[q+1])->isAllocated())
			{
				allocated_bitmaps[q] = STATE_FREE;
				allocated_bitmaps[q+1] = NULL;
			}
		}
	}
	/**> Timezones */
	enum { 
		tzGMT, tzBST, tzIST, tzADT, tzEDT, tzCDT, tzMDT, tzPDT,
		tzCET, tzWAT, tzEET, tzMSK, tzSMT, tzAZT, tzEAT, tzYDT,
		tzGET, tzMVT, tzMUT, tzNZT, tzCST, tzWST, tzBST, tzCAT,
		tzJST, tzEST, tzPKT, tzWAT, tzART, tzAST, tzYST, tzHST,
		tzHDT, tzAT, tzNT, tzCXT, tzCST, tzMST, tzPST, tzWEDT,
		tzWEST, tzCEDT, tzCEST, tzMEDT, tzMEST, tzMESZ, tzEEDT, tzNZDT,
		tzEEST, tzEADT, tzWADT, tzHADT, tzAKDT, tzIDLW, tzAHST, tzAKST,
		tzHAST, tzUSZ1, tzYEKT, tzOMSK, tzKRAT, tzIRKT, tzAWST, tzEAST,
		tzVLAT, tzSAKT, tzIDLE, tzNZST, tzMAGT
	};
	const float VERSION = 1.1001;	/**< The header version ID */
	const int ALPHA = 7;		/**< The header Alpha ID */
	const int BETA = 0;		/**< The header Beta ID */
	const int GAMMA = 0;		/**< The header Gamma ID */
	const int RELEASE = 0;		/**< The header Release ID */
	const int YEAR = 2019;		/**< The header Year of Update */
	const int MONTH = 11;		/**< The header Month of Update */
	const int DAY = 19;		/**< The header Day of Update */
	const int HOUR = 9;		/**< The header Hour of Update */
	const int MINUTE = 53;		/**< The header Minute of Update */
	const int TIMEZONE = tzGMT;	/**< The header Timezone of Update */
	/*!
	*	Returns the datestamp of the header in the format of DDMM.YYYY
	*/
	float GetDatestamp()
	{
		float dt = MONTH;
		dt += DAY * 100;
		dt += YEAR / 10000;
		return dt;
	}
	/*!
	*	Returns the timestamp of the header in the format of HH.MM
	*/
	float GetTimestamp()
	{
		float tm = HOUR;
		tm += MINUTE / 10000;
		return tm;
	}
	/*!
	*	Returns the version ID as a wrapper. 
	*/
	float GetVersion()
	{
		return VERSION;
	}
	/*!
	*	Prints all header version metadata to the logfile and to the console. 
	*/
	void PrintVersionInfo()
	{
		printf("Bitmap.zh version %f", VERSION);
		if ( ALPHA ) printf(", Alpha %d\n", ALPHA);
		else if ( BETA ) printf(", Beta %d\n", BETA);
		else if ( GAMMA ) printf(", Gamma %d\n", GAMMA);
		else if ( RELEASE ) printf(", Release %d\n", RELEASE);
		else printf("\n");
		PrintDate();
	}
	/*!
	*	Generic function for printing the date in a human-friendly manner. 
	* 	Prints as "0th, Nonetober, 9999"
	*/
	void PrintDate()
	{
		int day[5];
		int month[10];
		int timezone[5];
		switch(DAY)
		{
			case 1:
			case 21:
			case 31:
				sprintf(temp,"%d%s",dy,"st"); 
				break;
			//nd
			case 2:
			case 22:
				sprintf(temp,"%d%s",dy,"nd"); 
				break;
			//rd
			case 3:
			case 23:
				sprintf(temp,"%d%s",dy,"rd"); 
				break;
			//th
			default:
				sprintf(temp,"%d%s",dy,"th");
				break;
		}
		
		switch(MONTH)
		{
			case 1:
				strcpy(month, "January"); break;
			case 2:
				strcpy(month, "February"); break;
			case 3:
				strcpy(month, "March"); break;
			case 4:
				strcpy(month, "April"); break;
			case 5:
				strcpy(month, "May"); break;
			case 6:
				strcpy(month, "June"); break;
			case 7:
				strcpy(month, "July"); break;
			case 8:
				strcpy(month, "August"); break;
			case 9:
				strcpy(month, "September"); break;
			case 10:
				strcpy(month, "October"); break;
			case 11:
				strcpy(month, "November"); break;
			case 12:
				strcpy(month, "December"); break;
			
		}
		switch(TIMEZONE)
		{
			case tzGMT: strcpy(timezone, "GMT"); break;
			case tzBST: strcpy(timezone, "BST"); break;
			case tzIST: strcpy(timezone, "IST"); break;
			case tzADT: strcpy(timezone, "ADT"); break;
			case tzEDT: strcpy(timezone, "EDT"); break;
			case tzCDT: strcpy(timezone, "CDT"); break;
			case tzMDT: strcpy(timezone, "MDT"); break;
			case tzPDT: strcpy(timezone, "PDT"); break;
			case tzCET: strcpy(timezone, "CET"); break;
			case tzWAT: strcpy(timezone, "WAT"); break;
			case tzEET: strcpy(timezone, "EET"); break;
			case tzMSK: strcpy(timezone, "MSK"); break;
			case tzSMT: strcpy(timezone, "SMT"); break;
			case tzAZT: strcpy(timezone, "AZT"); break;
			case tzEAT: strcpy(timezone, "EAT"); break;
			case tzYDT: strcpy(timezone, "YDT"); break;
			case tzGET: strcpy(timezone, "GET"); break;
			case tzMVT: strcpy(timezone, "MVT"); break;
			case tzMUT: strcpy(timezone, "MUT"); break;
			case tzNZT: strcpy(timezone, "NZT"); break;
			case tzCST: strcpy(timezone, "CST"); break;
			case tzWST: strcpy(timezone, "WST"); break;
			case tzBST: strcpy(timezone, "BST"); break;
			case tzCAT: strcpy(timezone, "CAT"); break;
			case tzJST: strcpy(timezone, "JST"); break;
			case tzEST: strcpy(timezone, "EST"); break;
			case tzPKT: strcpy(timezone, "PKT"); break;
			case tzWAT: strcpy(timezone, "WAT"); break;
			case tzART: strcpy(timezone, "ART"); break;
			case tzAST: strcpy(timezone, "AST"); break;
			case tzYST: strcpy(timezone, "YST"); break;
			case tzHST: strcpy(timezone, "HST"); break;
			case tzHDT: strcpy(timezone, "HDT"); break;
			case tzAT: strcpy(timezone, "AT"); break;
			case tzNT: strcpy(timezone, "NT"); break;
			case tzCXT: strcpy(timezone, "CXT"); break;
			case tzCST: strcpy(timezone, "CST"); break;
			case tzMST: strcpy(timezone, "MST"); break;
			case tzPST: strcpy(timezone, "PST"); break;
			case tzWEDT: strcpy(timezone, "WEDT"); break;
			case tzWEST: strcpy(timezone, "WEST"); break;
			case tzCEDT: strcpy(timezone, "CEDT"); break;
			case tzCEST: strcpy(timezone, "CEST"); break;
			case tzMEDT: strcpy(timezone, "MEDT"); break;
			case tzMEST: strcpy(timezone, "MEST"); break;
			case tzMESZ: strcpy(timezone, "MESZ"); break;
			case tzEEDT: strcpy(timezone, "EEDT"); break;
			case tzNZDT: strcpy(timezone, "NZDT"); break;
			case tzEEST: strcpy(timezone, "EEST"); break;
			case tzEADT: strcpy(timezone, "EADT"); break;
			case tzWADT: strcpy(timezone, "WADT"); break;
			case tzHADT: strcpy(timezone, "HADT"); break;
			case tzAKDT: strcpy(timezone, "AKDT"); break;
			case tzIDLW: strcpy(timezone, "IDLW"); break;
			case tzAHST: strcpy(timezone, "AHST"); break;
			case tzAKST: strcpy(timezone, "AKST"); break;
			case tzHAST: strcpy(timezone, "HAST"); break;
			case tzUSZ1: strcpy(timezone, "USZ1"); break;
			case tzYEKT: strcpy(timezone, "YEKT"); break;
			case tzOMSK: strcpy(timezone, "OMSK"); break;
			case tzKRAT: strcpy(timezone, "KRAT"); break;
			case tzIRKT: strcpy(timezone, "IRKT"); break;
			case tzAWST: strcpy(timezone, "AWST"); break;
			case tzEAST: strcpy(timezone, "EAST"); break;
			case tzVLAT: strcpy(timezone, "VLAT"); break;
			case tzSAKT: strcpy(timezone, "SAKT"); break;
			case tzIDLE: strcpy(timezone, "IDLE"); break;
			case tzNZST: strcpy(timezone, "NZST"); break;
			case tzMAGT: strcpy(timezone, "MAGT"); break;
			
		}
		printf("%s %s %d, at %d:%d %s\n", day, month, YEAR, HOUR, MINUTE, timezone);
	}
}