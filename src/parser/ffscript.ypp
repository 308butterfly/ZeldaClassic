/*
 Parser for the scripting language compiler. Inteded for use with Flex and Bison;
 use this file to generate y.tab.cpp //2.53 Updated to 16th Jan, 2017

command: bison -b y -v -d ffscript.ypp

*/

/* declarations */
%{
#include "../precompiled.h"
#include <stdlib.h>
#include <stdio.h>
#include <cassert>
#include "AST.h"
#include "UtilVisitors.h"
#include "../zsyssimple.h"
#define YYINCLUDED_STDLIB_H
extern int yydebug;
extern int yylineno;
extern char* yytext;
extern int yylex(void);
extern FILE *yyin;
extern ASTProgram *resAST;
extern void resetLexer();
void yyerror(const char* s);
string curfilename;
extern YYLTYPE noloc;

// Since c macros can't directly contain bison macros, they need to be passed
// in where they're invoked. The following arguments are named so that 'd'
// stands in for '$' and 'a' stands in for '@'.

#define PREFIX(klass, dd, d2, ad) \
	klass* prefix = new klass(ad); \
	ASTExpr* operand = (ASTExpr*)d2; \
	prefix->setOperand(operand); \
	dd = prefix;

#define POSTFIX(klass, dd, d1, ad) \
	klass* postfix = new klass(ad); \
	ASTExpr* operand = (ASTExpr*)d1; \
	postfix->setOperand(operand); \
	dd = postfix;

#define BINARY(klass, dd, d1, d3, ad) \
	ASTExpr* left = (ASTExpr*)d1; \
	ASTExpr* right = (ASTExpr*)d3; \
	dd = new klass(left, right, ad);

#define SHORTCUT(klass, dd, d1, d3, ad, a3)		\
	ASTExpr* left = (ASTExpr*)d1; \
	ASTExpr* right = (ASTExpr*)d3; \
	klass* rval = new klass(left->clone(), right, a3);	\
	dd = new ASTExprAssign(left, rval, ad);

%}

%glr-parser
%expect 1
%expect-rr 1
%error-verbose
%start Init

%token SCRIPT
%token ZFLOAT
%token FOR
%token ZBOOL
%token ZVOID
%token IF
%token ELSE
%token SWITCH
%token CASE
%token DEFAULT
%token RETURN
%token IMPORT
%token ZTRUE
%token ZFALSE
%token WHILE
%token FFC
%token ITEM
%token ITEMCLASS
%token GLOBAL
%token BREAK
%token CONTINUE
%token ZCONST
%token DO
%token NPC
%token LWEAPON
%token EWEAPON
%token GRAPHICS
%token SPRITEDATA
%token MAPDATA
%token NPCDATA
%token COMBODATA
%token DMAPDATA
%token MESSAGEDATA
%token SHOPDATA
%token UNTYPED
%token DROPDATA
%token PONDDATA
%token WARPRING
%token DOORSET
%token MISCCOLORS
%token RGBDATA
%token PALETTE
%token MUSICTRACK
%token PALCYCLE
%token GAMEDATA
%token CHEATS
%token TYPEDEF

%token ASSIGN
%token COLON
%token SEMICOLON
%token COMMA
%token LBRACKET
%token RBRACKET
%token LPAREN
%token RPAREN
%token DOT
%token LBRACE
%token RBRACE
%token ARROW

%token NUMBER
%token PLUSASSIGN
%token MINUSASSIGN
%token TIMESASSIGN
%token DIVIDEASSIGN
%token ANDASSIGN
%token ORASSIGN
%token BITANDASSIGN
%token BITORASSIGN
%token BITXORASSIGN
%token MODULOASSIGN
%token LSHIFTASSIGN
%token RSHIFTASSIGN
%token IDENTIFIER
%token QUOTEDSTRING
%token SINGLECHAR

%token COMPILEERROR

%left LSHIFT RSHIFT
%left BITAND BITOR BITXOR
%left AND OR
%left NOT BITNOT
%left INCREMENT DECREMENT
%left LE LT GE GT EQ NE
%left PLUS MINUS
%left TIMES DIVIDE
%left MODULO

%token PREPROCESS
%token DEFINE


%%

Init :
	Init GlobalStmt {
		resAST->addDeclaration((ASTDecl*)$2);}
	| {
		resAST = new ASTProgram(noloc);}
	;

GlobalStmt : Script {$$ = $1;}
	| Import {$$ = $1;}
	| FuncDecl {$$ = $1;}
	| DataDeclList SEMICOLON {$$ = $1;}
	| TypeDef SEMICOLON {$$ = $1;}
	;

////////////////
// Data Declarations.

// Common

DataDeclExtraArray :
	LBRACKET DataDeclExtraArray_SizeList RBRACKET {
			ASTDataDeclExtraArray* extraArray = (ASTDataDeclExtraArray*)$2;
			extraArray->updateLocation(@$);
			$$ = extraArray;}
	| LBRACKET RBRACKET {$$ = new ASTDataDeclExtraArray(@$);}
	;

DataDeclExtraArray_SizeList :
	DataDeclExtraArray_SizeList COMMA ConstExpr {
			ASTDataDeclExtraArray* extraArray = (ASTDataDeclExtraArray*)$1;
			ASTExpr* size = (ASTExpr*)$3;
			extraArray->dimensions.push_back(size);
			extraArray->updateLocation(@$);
			$$ = extraArray;}
	| ConstExpr {
			ASTExpr* size = (ASTExpr*)$1;
			ASTDataDeclExtraArray* extraArray = new ASTDataDeclExtraArray(@$);
			extraArray->dimensions.push_back(size);
			$$ = extraArray;}
	;

// Data Decl List

DataDeclList : Type DataDeclList_1 {
		ASTVarType* type = (ASTVarType*)$1;
		ASTDataDeclList* list = (ASTDataDeclList*)$2;
		list->baseType = type;
		list->updateLocation(@$);
		$$ = list;}
	;

DataDeclList_1 :
	DataDeclList_1 COMMA DataDeclList_Element {
			ASTDataDeclList* list = (ASTDataDeclList*)$1;
			ASTDataDecl* element = (ASTDataDecl*)$3;
			list->addDeclaration(element);
			list->updateLocation(@$);
			$$ = list;}
	| DataDeclList_Element {
			ASTDataDecl* element = (ASTDataDecl*)$1;
			ASTDataDeclList* list = new ASTDataDeclList(@$);
			list->addDeclaration(element);
			$$ = list;}
	;

DataDeclList_Element :
	DataDeclList_Element_1 ASSIGN Expr {
			ASTDataDecl* element = (ASTDataDecl*)$1;
			ASTExpr* initializer = (ASTExpr*)$3;
			element->setInitializer(initializer);
			element->updateLocation(@$);
			$$ = element;}
	| DataDeclList_Element_1 {$$ = $1;}
	;

DataDeclList_Element_1 :
	DataDeclList_Element_1 DataDeclExtraArray {
			ASTDataDecl* element = (ASTDataDecl*)$1;
			ASTDataDeclExtraArray* extraArray = (ASTDataDeclExtraArray*)$2;
			element->extraArrays.push_back(extraArray);
			element->updateLocation(@$);
			$$ = element;}
	| IDENTIFIER {
			ASTString* name = (ASTString*)$1;
			ASTDataDecl* element = new ASTDataDecl(@$);
			element->name = name->getValue();
			$$ = element;
																			delete name;}
	;

// Single Data Decl.

DataDecl : Type DataDecl_1 {
		ASTVarType* type = (ASTVarType*)$1;
		ASTDataDecl* data = (ASTDataDecl*)$2;
		data->baseType = type;
		data->updateLocation(@$);
		$$ = data;}
	;


DataDecl_1 :
	DataDecl_2 {$$ = $1;}
	| DataDecl_2 ASSIGN Expr {
			ASTDataDecl* data = (ASTDataDecl*)$1;
			ASTExpr* initializer = (ASTExpr*)$3;
			data->setInitializer(initializer);
			data->updateLocation(@$);
			$$ = data;}
	;

DataDecl_2 :
	DataDecl_2 DataDeclExtraArray {
			ASTDataDecl* data = (ASTDataDecl*)$1;
			ASTDataDeclExtraArray* extraArray = (ASTDataDeclExtraArray*)$2;
			data->extraArrays.push_back(extraArray);
			data->updateLocation(@$);
			$$ = data;}
	| IDENTIFIER {
			ASTString* name = (ASTString*)$1;
			ASTDataDecl* data = new ASTDataDecl(@$);
			data->name = name->getValue();
			$$ = data;
			delete name;}
	;

////////////////
// Function Declaration

FuncDecl :
	Type IDENTIFIER LPAREN FuncDecl_ParamList RPAREN Block {
			ASTVarType* returnType = (ASTVarType*)$1;
			ASTString* name = (ASTString*)$2;
			ASTFuncDecl* func = (ASTFuncDecl*)$4;
			ASTBlock* block = (ASTBlock*)$6;
			func->returnType = returnType;
			func->name = name->getValue();
			func->block = block;
			func->updateLocation(@$);
			$$ = func;
			delete name;}
	| Type IDENTIFIER LPAREN RPAREN Block {
			ASTVarType* returnType = (ASTVarType*)$1;
			ASTString* name = (ASTString*)$2;
			ASTBlock* block = (ASTBlock*)$5;
			ASTFuncDecl* func = new ASTFuncDecl(@$);
			func->returnType = returnType;
			func->name = name->getValue();
			func->block = block;
			$$ = func;
																delete name;}
	;

FuncDecl_ParamList :
	FuncDecl_ParamList COMMA DataDecl {
			ASTFuncDecl* func = (ASTFuncDecl*)$1;
			ASTDataDecl* param = (ASTDataDecl*)$3;
			func->addParameter(param);
			func->updateLocation(@$);
			$$ = func;}
	| DataDecl {
			ASTDataDecl* param = (ASTDataDecl*)$1;
			ASTFuncDecl* func = new ASTFuncDecl(@$);
			func->addParameter(param);
			$$ = func;}
	;

////////////////
// Compile Error

CompileError : COMPILEERROR LPAREN ConstExpr RPAREN StmtNoSemi {
		ASTExpr* errorId = (ASTExpr*)$3;
		ASTStmt* statement = (ASTStmt*)$5;
		$$ = new ASTCompileError(errorId, statement, @$);}
	;
	
////////////////

Script : ScriptType SCRIPT IDENTIFIER ScriptBlock {
			ASTScriptType* type = (ASTScriptType*)$1;
			ASTString* name = (ASTString*)$3;
			ASTScript* script = (ASTScript*)$4;
			script->setType(type);
			script->setName(name->getValue());
			script->updateLocation(@$);
			$$ = script;
												   delete name;}
	;

ScriptType : GLOBAL {$$ = new ASTScriptType(SCRIPTTYPE_GLOBAL, @1);}
	| FFC {$$ = new ASTScriptType(SCRIPTTYPE_FFC, @1);}
	| ITEM {$$ = new ASTScriptType(SCRIPTTYPE_ITEM, @1);}
		   ;

Import : IMPORT QUOTEDSTRING	{ASTString *str = (ASTString *)$2;
								 $$ = new ASTImportDecl(str->getValue(),@1);
								 delete str;}
	;

ScriptBlock : LBRACE ScriptStmtList RBRACE {$$ = $2;}
	| LBRACE RBRACE {
		$$ = new ASTScript(@$);}
	;

ScriptStmtList :
	ScriptStmtList ScriptStmt {
		ASTScript* script = (ASTScript*)$1;
		ASTDecl* declaration = (ASTDecl*)$2;
		script->addDeclaration(*declaration);
		script->updateLocation(@$);
		$$ = script;}
	| ScriptStmt {
		ASTScript* script = new ASTScript(@$);
		ASTDecl* declaration = (ASTDecl*)$1;
		script->addDeclaration(*declaration);
		$$ = script;}
	;

ScriptStmt :
	DataDeclList SEMICOLON {$$ = $1;}
	| FuncDecl {$$ = $1;}
	| TypeDef SEMICOLON {$$ = $1;}
	;

Type : ZVOID {$$ = new ASTVarType(ZVarTypeSimple::ZVOID, @1);}
	| ZFLOAT {$$ = new ASTVarType(ZVarTypeSimple::FLOAT, @1);}
	| ZBOOL {$$ = new ASTVarType(ZVarTypeSimple::BOOL, @1);}
	| FFC {$$ = new ASTVarType(ZVarTypeSimple::FFC, @1);}
	| ITEM {$$ = new ASTVarType(ZVarTypeSimple::ITEM, @1);}
	| ITEMCLASS {$$ = new ASTVarType(ZVarTypeSimple::ITEMCLASS, @1);}
	| NPC	{$$ = new ASTVarType(ZVarTypeSimple::NPC, @1);}
	| LWEAPON	{$$ = new ASTVarType(ZVarTypeSimple::LWPN, @1);}
	| EWEAPON	{$$ = new ASTVarType(ZVarTypeSimple::EWPN, @1);}
	| SPRITEDATA	{$$ = new ASTVarType(ZVarTypeSimple::SPRITEDATA, @1);}
	| MAPDATA	{$$ = new ASTVarType(ZVarTypeSimple::MAPDATA, @1);}
	| NPCDATA	{$$ = new ASTVarType(ZVarTypeSimple::NPCDATA, @1);}
	| COMBODATA	{$$ = new ASTVarType(ZVarTypeSimple::COMBOS, @1);}
	| GRAPHICS	{$$ = new ASTVarType(ZVarTypeSimple::GRAPHICS, @1);}
	| DMAPDATA	{$$ = new ASTVarType(ZVarTypeSimple::DMAPDATA, @1);}
	| MESSAGEDATA	{$$ = new ASTVarType(ZVarTypeSimple::ZMESSAGE, @1);}
	| SHOPDATA	{$$ = new ASTVarType(ZVarTypeSimple::SHOPDATA, @1);}
//	| UNTYPED	{$$ = new ASTVarType(ZVarTypeSimple::UNTYPED, @1);}
	| DROPDATA	{$$ = new ASTVarType(ZVarTypeSimple::DROPSET, @1);}
	| PONDDATA	{$$ = new ASTVarType(ZVarTypeSimple::PONDS, @1);}
	| WARPRING	{$$ = new ASTVarType(ZVarTypeSimple::WARPRING, @1);}
	| DOORSET	{$$ = new ASTVarType(ZVarTypeSimple::DOORSET, @1);}
	| MISCCOLORS	{$$ = new ASTVarType(ZVarTypeSimple::ZUICOLOURS, @1);}
	| RGBDATA	{$$ = new ASTVarType(ZVarTypeSimple::RGBDATA, @1);}
	| PALETTE	{$$ = new ASTVarType(ZVarTypeSimple::PALETTE, @1);}
	| MUSICTRACK	{$$ = new ASTVarType(ZVarTypeSimple::TUNES, @1);}
	| PALCYCLE	{$$ = new ASTVarType(ZVarTypeSimple::PALCYCLE, @1);}
	| GAMEDATA	{$$ = new ASTVarType(ZVarTypeSimple::GAMEDATA, @1);}
	| CHEATS	{$$ = new ASTVarType(ZVarTypeSimple::CHEATS, @1);}
	| IDENTIFIER {
		ASTString *name = (ASTString*)$1;
		$$ = new ASTVarType(ZVarTypeUnresolved(name->getValue()), @1);
		delete name;}
	| ZCONST ZFLOAT {$$ = new ASTVarType(new ZVarTypeConstFloat(), @1);}
	;

Block : LBRACE StmtList RBRACE  {$$ = $2;}
	| LBRACE RBRACE {$$ = new ASTBlock(@1);}
	;

StmtList : Stmt {
			ASTStmt* stmt = (ASTStmt*)$1;
			ASTBlock *block = new ASTBlock(@1);
				  block->addStatement(stmt);
				  $$ = block;}
  | StmtList Stmt {
			ASTBlock *block = (ASTBlock *)$1;
			ASTStmt *stmt = (ASTStmt *)$2;
		  block->addStatement(stmt);
		  $$ = block;}
	;

Stmt :
	DataDeclList SEMICOLON {$$ = $1;}
	| ForStmt {$$ = $1;}
	| IfStmt {$$ = $1;}
	| SwitchStmt {$$ = $1;}
	| Block {$$ = $1;}
	| ReturnStmt SEMICOLON {$$ = $1;}
	| WhileStmt {$$ = $1;}
	| DoStmt {$$ = $1;}
	| SEMICOLON {$$ = new ASTStmtEmpty(@1);}
	| Expr SEMICOLON {$$ = $1;}
	| BREAK SEMICOLON {$$ = new ASTStmtBreak(@1);}
	| CONTINUE SEMICOLON {$$ = new ASTStmtContinue(@1);}
	| TypeDef SEMICOLON {$$ = $1;}
	| CompileError SEMICOLON {$$ = $1;}
	;

StmtNoSemi :
	DataDeclList {$$ = $1;}
	| ForStmt {$$ = $1;}
	| IfStmt {$$ = $1;}
	| SwitchStmt {$$ = $1;}
	| Block {$$ = $1;}
	| ReturnStmt {$$ = $1;}
	| WhileStmt {$$ = $1;}
	| DoStmt {$$ = $1;}
	| {$$ = new ASTStmtEmpty(noloc);}
	| Expr {$$ = $1;}
	| BREAK {$$ = new ASTStmtBreak(@1);}
	| CONTINUE {$$ = new ASTStmtContinue(@1);}
	| TypeDef {$$ = $1;}
	| CompileError {$$ = $1;}
	;

TypeDef : TYPEDEF Type IDENTIFIER {
	ASTVarType* type = (ASTVarType*)$2;
	ASTString* name = (ASTString*)$3;
	$$ = new ASTTypeDef(type, name->getValue(), @1);
	delete name;}
	;

////////////////////////////////////////////////////////////////
// Expression Helpers

Identifier :
	IDENTIFIER {
			ASTString* rval = (ASTString*)$1;
		$$ = new ASTExprIdentifier(rval->getValue(), @$);
		delete rval;}
	| Identifier DOT IDENTIFIER {
		ASTExprIdentifier* identifier = (ASTExprIdentifier*)$1;
		ASTString* name = (ASTString *)$3;
		identifier->appendComponent(name->getValue());
		identifier->updateLocation(@$);
		$$ = identifier;
		delete name;}
	;

FunctionCall :
	Expr_2 LPAREN RPAREN {
		ASTExprCall* call = new ASTExprCall(@$);
		ASTExpr* left = (ASTExpr*)$1;
		call->setLeft(left);
		call->updateLocation(@$);
		$$ = call;}
	| Expr_2 LPAREN FunctionCallArgs RPAREN {
		ASTExpr* left = (ASTExpr*)$1;
		ASTExprCall* call = (ASTExprCall*)$3;
		call->setLeft(left);
		call->updateLocation(@$);
		$$ = call;}
	;

FunctionCallArgs :
	Expr {
		ASTExprCall* call = new ASTExprCall(@$);
		ASTExpr* e = (ASTExpr*)$1;
		call->addParam(e);
		$$ = call;}
	| FunctionCallArgs COMMA Expr {
		ASTExprCall* call = (ASTExprCall*)$1;
		ASTExpr* e = (ASTExpr*)$3;
		call->addParam(e);
		call->updateLocation(@$);
		$$ = call;}
	;

BoolConstant :
	ZTRUE {$$ = new ASTBoolLiteral(true, @$);}
	| ZFALSE {$$ = new ASTBoolLiteral(false, @$);}
	;

ArrayLiteral :
	LBRACE ArrayLiteralList RBRACE {
			ASTArrayLiteral* al = (ASTArrayLiteral*)$2;
			al->updateLocation(@$);
			$$ = al;}
	| LPAREN Type LBRACKET RBRACKET RPAREN LBRACE ArrayLiteralList RBRACE {
			ASTVarType* type = (ASTVarType*)$2;
			ASTArrayLiteral* al = (ASTArrayLiteral*)$7;
			al->setType(type);
			al->updateLocation(@$);
			$$ = al;}
	| LPAREN Type LBRACKET ConstExpr RBRACKET RPAREN LBRACE ArrayLiteralList RBRACE {
			ASTVarType* type = (ASTVarType*)$2;
			ASTExpr* size = (ASTExpr*)$4;
			ASTArrayLiteral* al = (ASTArrayLiteral*)$8;
			al->setType(type);
			al->setSize(size);
			al->updateLocation(@$);
			$$ = al;}
	| LPAREN Type LBRACKET RBRACKET RPAREN LBRACE RBRACE {
			ASTVarType* type = (ASTVarType*)$2;
			ASTArrayLiteral* al = new ASTArrayLiteral(@$);
			al->setType(type);
			$$ = al;}
	| LPAREN Type LBRACKET ConstExpr RBRACKET RPAREN LBRACE RBRACE {
			ASTVarType* type = (ASTVarType*)$2;
			ASTExpr* size = (ASTExpr*)$4;
			ASTArrayLiteral* al = new ASTArrayLiteral(@$);
			al->setType(type);
			al->setSize(size);
			$$ = al;}
	;

ArrayLiteralList :
	Expr {
			ASTExpr* element = (ASTExpr*)$1;
			ASTArrayLiteral* al = new ASTArrayLiteral(@$);
			al->appendElement(element);
			$$ = al;}
	| ArrayLiteralList COMMA Expr {
			ASTArrayLiteral* al = (ASTArrayLiteral*)$1;
			ASTExpr* element = (ASTExpr*)$3;
			al->appendElement(element);
			$$ = al;}
	;

////////////////////////////////////////////////////////////////
// Expressions - in order of precedence.
//   (Roughly following http://en.cppreference.com/w/cpp/language/operator_precedence).

Expr_1 : Identifier {$$ = $1;}
	| NUMBER {
			ASTFloat* val = (ASTFloat*)$1;
			$$ = new ASTNumberLiteral(val, @$);}
	| SINGLECHAR {
			ASTString* as = (ASTString*)$1;
			char val[15];
			sprintf(val, "%d", as->getValue().at(1));
			$$ = new ASTNumberLiteral(new ASTFloat(val, 0, @$), @$);}
	| QUOTEDSTRING {
			ASTString* rawstring = (ASTString*)$1;
			ASTStringLiteral* str = new ASTStringLiteral(*rawstring);
			delete rawstring;
			$$ = str;}
	| BoolConstant {$$ = $1;}
	| ArrayLiteral {$$ = $1;}
	| LPAREN Expr RPAREN {$$ = $2;}
	;

Expr_2 : Expr_1 {$$ = $1;}
  // Post Increment
	| Expr_2 INCREMENT {POSTFIX(ASTExprIncrement, $$, $1, @$)}
  // Post Decrement
	| Expr_2 DECREMENT {POSTFIX(ASTExprDecrement, $$, $1, @$)}
  // Function Call
	| FunctionCall {$$ = $1;}
	// Subscript
	| Expr_2 LBRACKET Expr RBRACKET {BINARY(ASTExprIndex, $$, $1, $3, @$)}
	// Access
	| Expr_2 ARROW IDENTIFIER {
			ASTExpr* left = (ASTExpr*)$1;
			ASTString* right = (ASTString*)$3;
			$$ = new ASTExprArrow(left, right->getValue(), @$);
			delete right;}
	;

Expr_3 : Expr_2 {$$ = $1;}
	// Pre Increment
	| INCREMENT Expr_3 {PREFIX(ASTExprPreIncrement, $$, $2, @$)}
	// Pre Decrement
	| DECREMENT Expr_3 {PREFIX(ASTExprPreDecrement, $$, $2, @$)}
	// Unary Minus
	| MINUS Expr_3 {PREFIX(ASTExprNegate, $$, $2, @$)}
	// Logical Not
	| NOT Expr_3 {PREFIX(ASTExprNot, $$, $2, @$)}
	// Bitwise Not
	| BITNOT Expr_3 {PREFIX(ASTExprBitNot, $$, $2, @$)}
	;

Expr_4 : Expr_3 {$$ = $1;} // None used.

Expr_5 : Expr_4 {$$ = $1;}
	// Multiplication
	| Expr_5 TIMES Expr_4 {BINARY(ASTExprTimes, $$, $1, $3, @$)}
	// Division
	| Expr_5 DIVIDE Expr_4 {BINARY(ASTExprDivide, $$, $1, $3, @$)}
	// Remainder
	| Expr_5 MODULO Expr_4 {BINARY(ASTExprModulo, $$, $1, $3, @$)}
	;

Expr_6 : Expr_5 {$$ = $1;}
	// Addition
	| Expr_6 PLUS Expr_5 {BINARY(ASTExprPlus, $$, $1, $3, @$)}
	// Subtraction
	| Expr_6 MINUS Expr_5 {BINARY(ASTExprMinus, $$, $1, $3, @$)}
	;

Expr_7 : Expr_6 {$$ = $1;}
	// Left Shift
	| Expr_7 LSHIFT Expr_6 {BINARY(ASTExprLShift, $$, $1, $3, @$)}
	// Right Shift
	| Expr_7 RSHIFT Expr_6 {BINARY(ASTExprRShift, $$, $1, $3, @$)}
	;

Expr_8 : Expr_7 {$$ = $1;}
	// Less Than
	| Expr_8 LT Expr_7 {BINARY(ASTExprLT, $$, $1, $3, @$)}
	// Less Than or Equal
	| Expr_8 LE Expr_7 {BINARY(ASTExprLE, $$, $1, $3, @$)}
	// Greater Than
	| Expr_8 GT Expr_7 {BINARY(ASTExprGT, $$, $1, $3, @$)}
	// Greater Than or Equal
	| Expr_8 GE Expr_7 {BINARY(ASTExprGE, $$, $1, $3, @$)}
	;

Expr_9 : Expr_8 {$$ = $1;}
	// Equality
	| Expr_9 EQ Expr_8 {BINARY(ASTExprEQ, $$, $1, $3, @$)}
	// Inequality
	| Expr_9 NE Expr_8 {BINARY(ASTExprNE, $$, $1, $3, @$)}
	;

Expr_10 : Expr_9 {$$ = $1;}
	// Bitwise And
	| Expr_10 BITAND Expr_9 {BINARY(ASTExprBitAnd, $$, $1, $3, @$)}
	;

Expr_11 : Expr_10 {$$ = $1;}
	// Bitwise Xor
	| Expr_11 BITXOR Expr_10 {BINARY(ASTExprBitXor, $$, $1, $3, @$)}
	;

Expr_12 : Expr_11 {$$ = $1;}
	// Bitwise Or
	| Expr_12 BITOR Expr_11 {BINARY(ASTExprBitOr, $$, $1, $3, @$)}
	;

Expr_13 : Expr_12 {$$ = $1;}
	// Logical And
	| Expr_13 AND Expr_12 {BINARY(ASTExprAnd, $$, $1, $3, @$)}
	;

Expr_14 : Expr_13 {$$ = $1;}
	// Logical Or
	| Expr_14 OR Expr_13 {BINARY(ASTExprOr, $$, $1, $3, @$)}
	;

Expr_15 : Expr_14 {$$ = $1;}
	// Assignment
	| Expr_14 ASSIGN Expr_15 {BINARY(ASTExprAssign, $$, $1, $3, @$)}
	// Addition Assignment
	| Expr_14 PLUSASSIGN Expr_15 {SHORTCUT(ASTExprPlus, $$, $1, $3, @$, @3)}
	// Subtraction Assignment
	| Expr_14 MINUSASSIGN Expr_15 {SHORTCUT(ASTExprMinus, $$, $1, $3, @$, @3)}
	// Multiplication Assignment
	| Expr_14 TIMESASSIGN Expr_15 {SHORTCUT(ASTExprTimes, $$, $1, $3, @$, @3)}
	// Division Assignment
	| Expr_14 DIVIDEASSIGN Expr_15 {SHORTCUT(ASTExprDivide, $$, $1, $3, @$, @3)}
	// Modulus Assignment
	| Expr_14 MODULOASSIGN Expr_15 {SHORTCUT(ASTExprModulo, $$, $1, $3, @$, @3)}
	// Left Shift Assignment
	| Expr_14 LSHIFTASSIGN Expr_15 {SHORTCUT(ASTExprLShift, $$, $1, $3, @$, @3)}
	// Right Shift Assignment
	| Expr_14 RSHIFTASSIGN Expr_15 {SHORTCUT(ASTExprRShift, $$, $1, $3, @$, @3)}
	// Bitwise And Assignment
	| Expr_14 BITANDASSIGN Expr_15 {SHORTCUT(ASTExprBitAnd, $$, $1, $3, @$, @3)}
	// Bitwise Xor Assignment
	| Expr_14 BITXORASSIGN Expr_15 {SHORTCUT(ASTExprBitXor, $$, $1, $3, @$, @3)}
	// Bitwise Or Assignment
	| Expr_14 BITORASSIGN Expr_15 {SHORTCUT(ASTExprBitOr, $$, $1, $3, @$, @3)}
	// Logical And Assignment
	| Expr_14 ANDASSIGN Expr_15 {SHORTCUT(ASTExprAnd, $$, $1, $3, @$, @3)}
	// Logical Or Assignment
	| Expr_14 ORASSIGN Expr_15 {SHORTCUT(ASTExprOr, $$, $1, $3, @$, @3)}
		 ;

Expr : Expr_15 {$$ = $1;}
	;

ConstExpr : Expr {
		ASTExpr* content = (ASTExpr*)$1;
		$$ = new ASTExprConst(content, @$);}
	;

////////////////////////////////////////////////////////////////

ForStmt : FOR LPAREN StmtNoSemi SEMICOLON Expr SEMICOLON StmtNoSemi RPAREN Stmt {ASTStmt *prec = (ASTStmt *)$3;
												ASTExpr *term = (ASTExpr *)$5;
												ASTStmt *incr = (ASTExpr *)$7;
												ASTStmt *stmt = (ASTStmt *)$9;
												$$ = new ASTStmtFor(prec,term,incr,stmt,@1);}
	;

WhileStmt : WHILE LPAREN Expr RPAREN Stmt {ASTExpr *cond = (ASTExpr *)$3;
										   ASTStmt *stmt = (ASTStmt *)$5;
										   $$ = new ASTStmtWhile(cond,stmt,@1);}

DoStmt : DO Stmt WHILE LPAREN Expr RPAREN {ASTExpr *cond = (ASTExpr *)$5;
										   ASTStmt *stmt = (ASTStmt *)$2;
										   $$ = new ASTStmtDo(cond,stmt,@1);}

IfStmt : IF LPAREN Expr RPAREN Stmt {ASTExpr *cond = (ASTExpr *)$3;
							  ASTStmt *stmt = (ASTStmt *)$5;
							  $$ = new ASTStmtIf(cond,stmt,@1);}
	| IF LPAREN Expr RPAREN Stmt ELSE Stmt {ASTExpr *cond = (ASTExpr *)$3;
										ASTStmt *ifstmt = (ASTStmt *)$5;
										ASTStmt *elsestmt = (ASTStmt *)$7;
										$$ = new ASTStmtIfElse(cond,ifstmt,elsestmt,@1);}
	;

SwitchStmt : SWITCH LPAREN Expr RPAREN LBRACE SwitchStmt1 RBRACE {
		ASTExpr* key = (ASTExpr*)$3;
		ASTStmtSwitch* sw = (ASTStmtSwitch*)$6;
		sw->setKey(key);
		$$ = sw;}
	;
SwitchStmt1 : SwitchCases StmtList {
			ASTStmtSwitch* sw = new ASTStmtSwitch(@$);
			ASTSwitchCases* cases = (ASTSwitchCases*)$1;
			ASTBlock* block = (ASTBlock*)$2;
			cases->setBlock(block);
			sw->addCases(cases);
			$$ = sw;}
	| SwitchStmt1 SwitchCases StmtList {
			ASTStmtSwitch* sw = (ASTStmtSwitch*)$1;
			ASTSwitchCases* cases = (ASTSwitchCases*)$2;
			ASTBlock* block = (ASTBlock*)$3;
			cases->setBlock(block);
			sw->addCases(cases);
			$$ = sw;}
	;
SwitchCases : CASE ConstExpr COLON {
			ASTSwitchCases* cases = new ASTSwitchCases(@$);
			ASTExprConst* key = (ASTExprConst*)$2;
			cases->addCase(key);
			$$ = cases;}
	| DEFAULT COLON {
			ASTSwitchCases* cases = new ASTSwitchCases(@$);
			cases->addDefaultCase();
			$$ = cases;}
	| SwitchCases CASE ConstExpr COLON {
			ASTSwitchCases* cases = (ASTSwitchCases*)$1;
			ASTExprConst* key = (ASTExprConst*)$3;
			cases->addCase(key);
			$$ = cases;}
	| SwitchCases DEFAULT COLON {
			ASTSwitchCases* cases = (ASTSwitchCases*)$1;
			cases->addDefaultCase();
			$$ = cases;}
	;


ReturnStmt : RETURN Expr {$$ = new ASTStmtReturnVal((ASTExpr *)$2,@1);}
	| RETURN {$$ = new ASTStmtReturn(@1);}
	;

%%

/*        programs */

void yyerror(const char *s) {
	char temp[512];
    snprintf(temp, 512, "line %d: %s, on token %s", yylineno, s, yytext);
    box_out(temp);
    box_eol();
}

int go(const char *f)
{
yyin = NULL;
resetLexer();
yyin = fopen(f, "r");
if(!yyin)
{
	box_out("Can't open input file");
	box_eol();
	return -1;
}
	curfilename = string(f);
	int result = yyparse();
	fclose(yyin);
	return result;
}

