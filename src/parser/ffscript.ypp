/*
 Parser for the scripting language compiler. Inteded for use with Flex and Bison;
 use this file to generate y.tab.cpp //2.53 Updated to 16th Jan, 2017

command: bison -b y -v -d ffscript.ypp

*/

/* declarations */
%{
#include "../precompiled.h"
#include <stdlib.h>
#include <stdio.h>
#include <cassert>
#include "AST.h"
#include "UtilVisitors.h"
#include "../zsyssimple.h"
#define YYINCLUDED_STDLIB_H
extern int yydebug;
extern int yylineno;
extern char* yytext;
extern int yylex(void);
extern FILE *yyin;
extern ASTProgram *resAST;
extern void resetLexer();
void yyerror(const char* s);
string curfilename;
extern YYLTYPE noloc;

// Since c macros can't directly contain bison macros, they need to be passed
// in where they're invoked. The following arguments are named so that 'd'
// stands in for '$' and 'a' stands in for '@'.

#define PREFIX(klass, dd, d2, ad) \
	klass* prefix = new klass(ad); \
	ASTExpr* operand = (ASTExpr*)d2; \
	prefix->setOperand(operand); \
	dd = prefix;

#define POSTFIX(klass, dd, d1, ad) \
	klass* postfix = new klass(ad); \
	ASTExpr* operand = (ASTExpr*)d1; \
	postfix->setOperand(operand); \
	dd = postfix;

#define BINARY(klass, dd, d1, d3, ad) \
	ASTExpr* left = (ASTExpr*)d1; \
	ASTExpr* right = (ASTExpr*)d3; \
	dd = new klass(left, right, ad);

#define SHORTCUT(klass, dd, d1, d3, ad, a3)		\
	ASTExpr* left = (ASTExpr*)d1; \
	ASTExpr* right = (ASTExpr*)d3; \
	klass* rval = new klass(left, right, a3); \
	dd = new ASTStmtAssign(left, rval, ad);

%}
%expect 1
%error-verbose
%start Init

%token SCRIPT
%token ZFLOAT
%token FOR
%token ZBOOL
%token ZVOID
%token IF
%token ELSE
%token SWITCH
%token CASE
%token DEFAULT
%token RETURN
%token IMPORT
%token ZTRUE
%token ZFALSE
%token WHILE
%token FFC
%token ITEM
%token ITEMCLASS
%token GLOBAL
%token BREAK
%token CONTINUE
%token ZCONST
%token DO
%token NPC
%token LWEAPON
%token EWEAPON
%token GRAPHICS
%token SPRITEDATA
%token MAPDATA
%token NPCDATA
%token COMBODATA
%token DMAPDATA
%token MESSAGEDATA
%token SHOPDATA
%token UNTYPED
%token DROPDATA
%token PONDDATA
%token WARPRING
%token DOORSET
%token MISCCOLORS
%token RGBDATA
%token PALETTE
%token MUSICTRACK
%token PALCYCLE
%token GAMEDATA
%token CHEATS
%token TYPEDEF

%token ASSIGN
%token COLON
%token SEMICOLON
%token COMMA
%token LBRACKET
%token RBRACKET
%token LPAREN
%token RPAREN
%token DOT
%token LBRACE
%token RBRACE
%token ARROW

%token NUMBER
%token PLUSASSIGN
%token MINUSASSIGN
%token TIMESASSIGN
%token DIVIDEASSIGN
%token ANDASSIGN
%token ORASSIGN
%token BITANDASSIGN
%token BITORASSIGN
%token BITXORASSIGN
%token MODULOASSIGN
%token LSHIFTASSIGN
%token RSHIFTASSIGN
%token IDENTIFIER
%token QUOTEDSTRING
%token SINGLECHAR

%left LSHIFT RSHIFT
%left BITAND BITOR BITXOR
%left AND OR
%left NOT BITNOT
%left INCREMENT DECREMENT
%left LE LT GE GT EQ NE
%left PLUS MINUS
%left TIMES DIVIDE
%left MODULO

%token PREPROCESS
%token DEFINE


%%

Init :
	Init GlobalStmt {
		resAST->addDeclaration((ASTDecl*)$2);}
	| {
		resAST = new ASTProgram(noloc);}
	;

GlobalStmt : Script {$$ = $1;}
	| Import {$$ = $1;}
	| FuncDecl {$$ = $1;}
	| VarDecl SEMICOLON {$$ = $1;}
	| VarDecl ASSIGN Expr SEMICOLON {
			ASTVarDecl* vd = (ASTVarDecl*)$1;
			$$ = new ASTVarDeclInitializer(vd->getType()->clone(), vd->getName(), (ASTExpr*)$3, @1);
									delete vd;}
	| ArrayDecl SEMICOLON {$$ = $1;}
	| TypeDef SEMICOLON {$$ = $1;}
	;

ArrayDecl :
	Type IDENTIFIER LBRACKET ConstExpr RBRACKET {
			ASTVarType *type = (ASTVarType*)$1;
														ASTString *name = (ASTString *)$2;
														ASTExprConst *size = (ASTExprConst *)$4;
														$$ = new ASTArrayDecl(type, name->getValue(), size, NULL, @1);
														delete name;}
	| Type IDENTIFIER LBRACKET ConstExpr RBRACKET ASSIGN LBRACE ArrayList RBRACE {
			ASTVarType *type = (ASTVarType*)$1;
																				ASTString *name = (ASTString *)$2;
																				ASTExprConst *size = (ASTExprConst *)$4;
																				ASTArrayList *list = (ASTArrayList *)$8;
																				$$ = new ASTArrayDecl(type, name->getValue(), size, list, @1);
																				delete name;}
 	| Type IDENTIFIER LBRACKET RBRACKET ASSIGN LBRACE ArrayList RBRACE {
			ASTVarType *type = (ASTVarType*)$1;
																			ASTString *name = (ASTString *)$2;
																			ASTArrayList *list = (ASTArrayList *)$7;
																			char val[15];
																			sprintf(val, "%d", list->getList().size());
																			ASTExpr *size = new ASTNumConstant(new ASTFloat(val, 0, @1), @1);
																			$$ = new ASTArrayDecl(type, name->getValue(), size, list, @1);
																			delete name;}
	| Type IDENTIFIER LBRACKET ConstExpr RBRACKET ASSIGN QUOTEDSTRING {
			ASTVarType *type = (ASTVarType*)$1;
																		ASTString *name = (ASTString *)$2;
																		ASTExprConst *size = (ASTExprConst *)$4;
																		ASTArrayList *list = new ASTArrayList(@1);
																		ASTString *string = (ASTString *)$7;

																		list->makeString();
																		list->addString(string->getValue());

																		$$ = new ASTArrayDecl(type, name->getValue(), size, list, @1);
																		delete name;}

 	| Type IDENTIFIER LBRACKET RBRACKET ASSIGN QUOTEDSTRING {
			ASTVarType *type = (ASTVarType*)$1;
																ASTString *name = (ASTString *)$2;
																ASTArrayList *list = new ASTArrayList(@1);
																list->makeString();
																ASTString *string = (ASTString *)$6;
																ASTExpr *size = new ASTNumConstant(new ASTFloat(string->getValue().length()-1, 0, @1), @1);

																for(unsigned int i=1; i < string->getValue().length()-1; i++)
																	list->addParam(new ASTNumConstant(new ASTFloat(long((string->getValue())[i]), 0, @1), @1));

																list->addParam(new ASTNumConstant(new ASTFloat(0L, 0, @1), @1));
																$$ = new ASTArrayDecl(type, name->getValue(), size, list, @1);
																delete name;}
	;

ArrayList : ArrayList COMMA Expr {	ASTArrayList *al = (ASTArrayList *)$1;
									al->addParam((ASTExpr*)$3);
									$$=al;}
	| Expr {	ASTArrayList *al = new ASTArrayList(@1);
				al->addParam((ASTExpr *)$1);
				$$=al;}
	;

Script : ScriptType SCRIPT IDENTIFIER ScriptBlock {
			ASTScriptType *type = (ASTScriptType*)$1;
												   ASTString *name = (ASTString *)$3;
												   ASTDeclList *sblock = (ASTDeclList *)$4;
												   $$ = new ASTScript(type, name->getValue(), sblock,@1);
												   delete name;}
	;

ScriptType : GLOBAL {$$ = new ASTScriptType(SCRIPTTYPE_GLOBAL, @1);}
	| FFC {$$ = new ASTScriptType(SCRIPTTYPE_FFC, @1);}
	| ITEM {$$ = new ASTScriptType(SCRIPTTYPE_ITEM, @1);}
		   ;

Import : IMPORT QUOTEDSTRING	{ASTString *str = (ASTString *)$2;
								 $$ = new ASTImportDecl(str->getValue(),@1);
								 delete str;}
	;

ScriptBlock : LBRACE ScriptStmtList RBRACE {$$ = $2;}
	| LBRACE RBRACE {$$ = new ASTDeclList(@1);}
	;

ScriptStmtList : ScriptStmt ScriptStmtList {ASTDeclList *dl = (ASTDeclList *)$2;
											dl->addDeclaration((ASTDecl *)$1);
											$$ = dl;}
	| ScriptStmt {	ASTDeclList *dl = new ASTDeclList(@1);
					dl->addDeclaration((ASTDecl *)$1);
					$$ = dl;}
	;

ScriptStmt : VarDecl SEMICOLON {$$ = $1;}
	| ArrayDecl SEMICOLON {$$ = $1;}
	| VarDecl ASSIGN Expr SEMICOLON {
			ASTVarDecl *vd = (ASTVarDecl *)$1;
			$$ = new ASTVarDeclInitializer(vd->getType()->clone(), vd->getName(), (ASTExpr*)$3, @1);
						   delete vd;}
	| FuncDecl {$$ = $1;}
	| TypeDef SEMICOLON {$$ = $1;}
	;

VarDecl : Type IDENTIFIER {
		ASTVarType *type = (ASTVarType*)$1;
		ASTString *name = (ASTString*)$2;
		$$ = new ASTVarDecl(type, name->getValue(), @1);
				   delete name;}
	;

Type : ZVOID {$$ = new ASTVarType(ZVarTypeSimple::VOID, @1);}
	| ZFLOAT {$$ = new ASTVarType(ZVarTypeSimple::FLOAT, @1);}
	| ZBOOL {$$ = new ASTVarType(ZVarTypeSimple::BOOL, @1);}
	| FFC {$$ = new ASTVarType(ZVarTypeSimple::FFC, @1);}
	| ITEM {$$ = new ASTVarType(ZVarTypeSimple::ITEM, @1);}
	| ITEMCLASS {$$ = new ASTVarType(ZVarTypeSimple::ITEMCLASS, @1);}
	| NPC	{$$ = new ASTVarType(ZVarTypeSimple::NPC, @1);}
	| LWEAPON	{$$ = new ASTVarType(ZVarTypeSimple::LWPN, @1);}
	| EWEAPON	{$$ = new ASTVarType(ZVarTypeSimple::EWPN, @1);}
	| SPRITEDATA	{$$ = new ASTVarType(ZVarTypeSimple::SPRITEDATA, @1);}
	| MAPDATA	{$$ = new ASTVarType(ZVarTypeSimple::MAPDATA, @1);}
	| NPCDATA	{$$ = new ASTVarType(ZVarTypeSimple::NPCDATA, @1);}
	| COMBODATA	{$$ = new ASTVarType(ZVarTypeSimple::COMBOS, @1);}
	| GRAPHICS	{$$ = new ASTVarType(ZVarTypeSimple::GRAPHICS, @1);}
	| DMAPDATA	{$$ = new ASTVarType(ZVarTypeSimple::DMAPDATA, @1);}
	| MESSAGEDATA	{$$ = new ASTVarType(ZVarTypeSimple::ZMESSAGE, @1);}
	| SHOPDATA	{$$ = new ASTVarType(ZVarTypeSimple::SHOPDATA, @1);}
//	| UNTYPED	{$$ = new ASTVarType(ZVarTypeSimple::UNTYPED, @1);}
	| DROPDATA	{$$ = new ASTVarType(ZVarTypeSimple::DROPSET, @1);}
	| PONDDATA	{$$ = new ASTVarType(ZVarTypeSimple::PONDS, @1);}
	| WARPRING	{$$ = new ASTVarType(ZVarTypeSimple::WARPRING, @1);}
	| DOORSET	{$$ = new ASTVarType(ZVarTypeSimple::DOORSET, @1);}
	| MISCCOLORS	{$$ = new ASTVarType(ZVarTypeSimple::ZUICOLOURS, @1);}
	| RGBDATA	{$$ = new ASTVarType(ZVarTypeSimple::RGBDATA, @1);}
	| PALETTE	{$$ = new ASTVarType(ZVarTypeSimple::PALETTE, @1);}
	| MUSICTRACK	{$$ = new ASTVarType(ZVarTypeSimple::TUNES, @1);}
	| PALCYCLE	{$$ = new ASTVarType(ZVarTypeSimple::PALCYCLE, @1);}
	| GAMEDATA	{$$ = new ASTVarType(ZVarTypeSimple::GAMEDATA, @1);}
	| CHEATS	{$$ = new ASTVarType(ZVarTypeSimple::CHEATS, @1);}
	| IDENTIFIER {
		ASTString *name = (ASTString*)$1;
		$$ = new ASTVarType(ZVarTypeUnresolved(name->getValue()), @1);
		delete name;}
	| ZCONST ZFLOAT {$$ = new ASTVarType(new ZVarTypeConstFloat(), @1);}
	;

FuncDecl :
	Type IDENTIFIER LPAREN ParamList RPAREN Block {
			ASTFuncDecl *fd = (ASTFuncDecl *)$4;
			ASTVarType *rettype = (ASTVarType *)$1;
									    ASTString *name = (ASTString *)$2;
									    ASTBlock *block = (ASTBlock *)$6;
									    fd->setName(name->getValue());
									    delete name;
									    fd->setReturnType(rettype);
									    fd->setBlock(block);
			$$ = fd;}
	| Type IDENTIFIER LPAREN RPAREN Block {
			ASTFuncDecl *fd = new ASTFuncDecl(@1);
			ASTVarType *rettype = (ASTVarType*)$1;
							   ASTString *name = (ASTString *)$2;
							   ASTBlock *block = (ASTBlock *)$5;
							   fd->setName(name->getValue());
							   delete name;
							   fd->setReturnType(rettype);
							   fd->setBlock(block);
			$$ = fd;}
	;

ParamList : VarDecl COMMA ParamList {ASTFuncDecl *fd = (ASTFuncDecl *)$3;
						 fd->addParam((ASTVarDecl *)$1);
						 $$=fd;}
	| VarDecl {ASTFuncDecl *fd = new ASTFuncDecl(@1);
		     fd->addParam((ASTVarDecl *)$1);
		     $$=fd;}
	;

Block : LBRACE StmtList RBRACE  {$$=$2;}
	| LBRACE RBRACE {$$ = new ASTBlock(@1);}
	;

StmtList : Stmt {
			ASTStmt* stmt = (ASTStmt*)$1;
			ASTBlock *block = new ASTBlock(@1);
				  block->addStatement(stmt);
				  $$ = block;}
  | StmtList Stmt {
			ASTBlock *block = (ASTBlock *)$1;
			ASTStmt *stmt = (ASTStmt *)$2;
		  block->addStatement(stmt);
		  $$ = block;}
	;

Stmt : VarDecl SEMICOLON {$$ = $1;}
	| VarDecl ASSIGN Expr SEMICOLON {
			ASTVarDecl* vd = (ASTVarDecl*)$1;
			$$ = new ASTVarDeclInitializer(vd->getType()->clone(), vd->getName(), (ASTExpr*)$3, @1);
			delete vd;}
	| ArrayDecl SEMICOLON {$$ = $1;}
	| ForStmt {$$ = $1;}
	| IfStmt {$$ = $1;}
	| SwitchStmt {$$ = $1;}
	| Block {$$ = $1;}
	| ReturnStmt SEMICOLON {$$ = $1;}
	| WhileStmt {$$ = $1;}
	| DoStmt {$$ = $1;}
	| SEMICOLON {$$ = new ASTStmtEmpty(@1);}
	| Expr SEMICOLON {$$ = $1;}
	| BREAK SEMICOLON {$$ = new ASTStmtBreak(@1);}
	| CONTINUE SEMICOLON {$$ = new ASTStmtContinue(@1);}
	| TypeDef SEMICOLON {$$ = $1;}
	;

StmtNoSemi : VarDecl {$$ = $1;}
	| VarDecl ASSIGN Expr {
			ASTVarDecl* vd = (ASTVarDecl*)$1;
			$$ = new ASTVarDeclInitializer(vd->getType()->clone(), vd->getName(), (ASTExpr*)$3, @1);
			delete vd;}
	| ArrayDecl {$$ = $1;}
	| ForStmt {$$ = $1;}
	| IfStmt {$$ = $1;}
	| SwitchStmt {$$ = $1;}
	| Block {$$ = $1;}
	| ReturnStmt {$$ = $1;}
	| WhileStmt {$$ = $1;}
	| DoStmt {$$ = $1;}
	| {$$ = new ASTStmtEmpty(noloc);}
	| Expr {$$ = $1;}
	| BREAK {$$ = new ASTStmtBreak(@1);}
	| CONTINUE {$$ = new ASTStmtContinue(@1);}
	| TypeDef {$$ = $1;}
	;

TypeDef : TYPEDEF Type IDENTIFIER {
	ASTVarType* type = (ASTVarType*)$2;
	ASTString* name = (ASTString*)$3;
	$$ = new ASTTypeDef(type, name->getValue(), @1);
	delete name;}
	;

////////////////////////////////////////////////////////////////
// Expression Helpers

Identifier :
	IDENTIFIER {
			ASTString* rval = (ASTString*)$1;
		$$ = new ASTExprIdentifier(rval->getValue(), @$);
		delete rval;}
	| Identifier DOT IDENTIFIER {
		ASTExprIdentifier* identifier = (ASTExprIdentifier*)$1;
		ASTString* name = (ASTString *)$3;
		identifier->appendComponent(name->getValue());
		identifier->updateLocation(@$);
		$$ = identifier;
		delete name;}
	;

FunctionCall :
	Expr_2 LPAREN RPAREN {
		ASTFuncCall* fc = new ASTFuncCall(@$);
		ASTExpr* name = (ASTExpr*)$1;
		fc->setName(name);
		$$ = fc;}
	| Expr_2 LPAREN FunctionCallArgs RPAREN {
		ASTExpr* name = (ASTExpr*)$1;
		ASTFuncCall* fc = (ASTFuncCall*)$3;
		fc->setName(name);
		$$ = fc;}
	;

FunctionCallArgs :
	Expr {
		ASTFuncCall* fc = new ASTFuncCall(@$);
		ASTExpr* e = (ASTExpr*)$1;
		fc->addParam(e);
		$$ = fc;}
	| FunctionCallArgs COMMA Expr {
		ASTFuncCall* fc = (ASTFuncCall*)$1;
		ASTExpr* e = (ASTExpr*)$3;
		fc->addParam(e);
		fc->updateLocation(@$);
		$$ = fc;}
	;

BoolConstant :
	ZTRUE {$$ = new ASTBoolConstant(true, @$);}
	| ZFALSE {$$ = new ASTBoolConstant(false, @$);}
	;

////////////////////////////////////////////////////////////////
// Expressions - in order of precedence.
//   (Roughly following http://en.cppreference.com/w/cpp/language/operator_precedence).

Expr_1 : Identifier {$$ = $1;}
	| NUMBER {
			ASTFloat* val = (ASTFloat*)$1;
			$$ = new ASTNumConstant(val, @$);}
	| SINGLECHAR {
			ASTString* as = (ASTString*)$1;
			char val[15];
			sprintf(val, "%d", as->getValue().at(1));
			$$ = new ASTNumConstant(new ASTFloat(val, 0, @$), @$);}
	| QUOTEDSTRING {
			ASTString* rawstring = (ASTString*)$1;
			ASTStringConstant* str = new ASTStringConstant(*rawstring);
			delete rawstring;
			$$ = str;}
	| BoolConstant {$$ = $1;}
	| LPAREN Expr RPAREN {$$ = $2;}
	;

Expr_2 : Expr_1 {$$ = $1;}
  // Post Increment
	| Expr_2 INCREMENT {POSTFIX(ASTExprIncrement, $$, $1, @$)}
  // Post Decrement
	| Expr_2 DECREMENT {POSTFIX(ASTExprDecrement, $$, $1, @$)}
  // Function Call
	| FunctionCall {$$ = $1;}
	// Subscript
	| Expr_2 LBRACKET Expr RBRACKET {BINARY(ASTExprIndex, $$, $1, $3, @$)}
	// Access
	| Expr_2 ARROW IDENTIFIER {
			ASTExpr* left = (ASTExpr*)$1;
			ASTString* right = (ASTString*)$3;
			$$ = new ASTExprArrow(left, right->getValue(), @$);
			delete right;}
	;

Expr_3 : Expr_2 {$$ = $1;}
	// Pre Increment
	| INCREMENT Expr_3 {PREFIX(ASTExprPreIncrement, $$, $2, @$)}
	// Pre Decrement
	| DECREMENT Expr_3 {PREFIX(ASTExprPreDecrement, $$, $2, @$)}
	// Unary Minus
	| MINUS Expr_3 {PREFIX(ASTExprNegate, $$, $2, @$)}
	// Logical Not
	| NOT Expr_3 {PREFIX(ASTExprNot, $$, $2, @$)}
	// Bitwise Not
	| BITNOT Expr_3 {PREFIX(ASTExprBitNot, $$, $2, @$)}
	;

Expr_4 : Expr_3 {$$ = $1;} // None used.

Expr_5 : Expr_4 {$$ = $1;}
	// Multiplication
	| Expr_5 TIMES Expr_4 {BINARY(ASTExprTimes, $$, $1, $3, @$)}
	// Division
	| Expr_5 DIVIDE Expr_4 {BINARY(ASTExprDivide, $$, $1, $3, @$)}
	// Remainder
	| Expr_5 MODULO Expr_4 {BINARY(ASTExprModulo, $$, $1, $3, @$)}
	;

Expr_6 : Expr_5 {$$ = $1;}
	// Addition
	| Expr_6 PLUS Expr_5 {BINARY(ASTExprPlus, $$, $1, $3, @$)}
	// Subtraction
	| Expr_6 MINUS Expr_5 {BINARY(ASTExprMinus, $$, $1, $3, @$)}
	;

Expr_7 : Expr_6 {$$ = $1;}
	// Left Shift
	| Expr_7 LSHIFT Expr_6 {BINARY(ASTExprLShift, $$, $1, $3, @$)}
	// Right Shift
	| Expr_7 RSHIFT Expr_6 {BINARY(ASTExprRShift, $$, $1, $3, @$)}
	;

Expr_8 : Expr_7 {$$ = $1;}
	// Less Than
	| Expr_8 LT Expr_7 {BINARY(ASTExprLT, $$, $1, $3, @$)}
	// Less Than or Equal
	| Expr_8 LE Expr_7 {BINARY(ASTExprLE, $$, $1, $3, @$)}
	// Greater Than
	| Expr_8 GT Expr_7 {BINARY(ASTExprGT, $$, $1, $3, @$)}
	// Greater Than or Equal
	| Expr_8 GE Expr_7 {BINARY(ASTExprGE, $$, $1, $3, @$)}
	;

Expr_9 : Expr_8 {$$ = $1;}
	// Equality
	| Expr_9 EQ Expr_8 {BINARY(ASTExprEQ, $$, $1, $3, @$)}
	// Inequality
	| Expr_9 NE Expr_8 {BINARY(ASTExprNE, $$, $1, $3, @$)}
	;

Expr_10 : Expr_9 {$$ = $1;}
	// Bitwise And
	| Expr_10 BITAND Expr_9 {BINARY(ASTExprBitAnd, $$, $1, $3, @$)}
	;

Expr_11 : Expr_10 {$$ = $1;}
	// Bitwise Xor
	| Expr_11 BITXOR Expr_10 {BINARY(ASTExprBitXor, $$, $1, $3, @$)}
	;

Expr_12 : Expr_11 {$$ = $1;}
	// Bitwise Or
	| Expr_12 BITOR Expr_11 {BINARY(ASTExprBitOr, $$, $1, $3, @$)}
	;

Expr_13 : Expr_12 {$$ = $1;}
	// Logical And
	| Expr_13 AND Expr_12 {BINARY(ASTExprAnd, $$, $1, $3, @$)}
	;

Expr_14 : Expr_13 {$$ = $1;}
	// Logical Or
	| Expr_14 OR Expr_13 {BINARY(ASTExprOr, $$, $1, $3, @$)}
	;

Expr_15 : Expr_14 {$$ = $1;}
	// Assignment
	| Expr_15 ASSIGN Expr_14 {BINARY(ASTStmtAssign, $$, $1, $3, @$)}
	// Addition Assignment
	| Expr_15 PLUSASSIGN Expr_14 {SHORTCUT(ASTExprPlus, $$, $1, $3, @$, @3)}
	// Subtraction Assignment
	| Expr_15 MINUSASSIGN Expr_14 {SHORTCUT(ASTExprMinus, $$, $1, $3, @$, @3)}
	// Multiplication Assignment
	| Expr_15 TIMESASSIGN Expr_14 {SHORTCUT(ASTExprTimes, $$, $1, $3, @$, @3)}
	// Division Assignment
	| Expr_15 DIVIDEASSIGN Expr_14 {SHORTCUT(ASTExprDivide, $$, $1, $3, @$, @3)}
	// Modulus Assignment
	| Expr_15 MODULOASSIGN Expr_14 {SHORTCUT(ASTExprModulo, $$, $1, $3, @$, @3)}
	// Left Shift Assignment
	| Expr_15 LSHIFTASSIGN Expr_14 {SHORTCUT(ASTExprLShift, $$, $1, $3, @$, @3)}
	// Right Shift Assignment
	| Expr_15 RSHIFTASSIGN Expr_14 {SHORTCUT(ASTExprRShift, $$, $1, $3, @$, @3)}
	// Bitwise And Assignment
	| Expr_15 BITANDASSIGN Expr_14 {SHORTCUT(ASTExprBitAnd, $$, $1, $3, @$, @3)}
	// Bitwise Xor Assignment
	| Expr_15 BITXORASSIGN Expr_14 {SHORTCUT(ASTExprBitXor, $$, $1, $3, @$, @3)}
	// Bitwise Or Assignment
	| Expr_15 BITORASSIGN Expr_14 {SHORTCUT(ASTExprBitOr, $$, $1, $3, @$, @3)}
	// Logical And Assignment
	| Expr_15 ANDASSIGN Expr_14 {SHORTCUT(ASTExprAnd, $$, $1, $3, @$, @3)}
	// Logical Or Assignment
	| Expr_15 ORASSIGN Expr_14 {SHORTCUT(ASTExprOr, $$, $1, $3, @$, @3)}
		 ;

Expr : Expr_15 {$$ = $1;}
	;

ConstExpr : Expr {
		ASTExpr* content = (ASTExpr*)$1;
		$$ = new ASTExprConst(content, @$);}
	;

////////////////////////////////////////////////////////////////

ForStmt : FOR LPAREN StmtNoSemi SEMICOLON Expr SEMICOLON StmtNoSemi RPAREN Stmt {ASTStmt *prec = (ASTStmt *)$3;
												ASTExpr *term = (ASTExpr *)$5;
												ASTStmt *incr = (ASTExpr *)$7;
												ASTStmt *stmt = (ASTStmt *)$9;
												$$ = new ASTStmtFor(prec,term,incr,stmt,@1);}
	;

WhileStmt : WHILE LPAREN Expr RPAREN Stmt {ASTExpr *cond = (ASTExpr *)$3;
										   ASTStmt *stmt = (ASTStmt *)$5;
										   $$ = new ASTStmtWhile(cond,stmt,@1);}

DoStmt : DO Stmt WHILE LPAREN Expr RPAREN {ASTExpr *cond = (ASTExpr *)$5;
										   ASTStmt *stmt = (ASTStmt *)$2;
										   $$ = new ASTStmtDo(cond,stmt,@1);}

IfStmt : IF LPAREN Expr RPAREN Stmt {ASTExpr *cond = (ASTExpr *)$3;
							  ASTStmt *stmt = (ASTStmt *)$5;
							  $$ = new ASTStmtIf(cond,stmt,@1);}
	| IF LPAREN Expr RPAREN Stmt ELSE Stmt {ASTExpr *cond = (ASTExpr *)$3;
										ASTStmt *ifstmt = (ASTStmt *)$5;
										ASTStmt *elsestmt = (ASTStmt *)$7;
										$$ = new ASTStmtIfElse(cond,ifstmt,elsestmt,@1);}
	;

SwitchStmt : SWITCH LPAREN Expr RPAREN LBRACE SwitchStmt1 RBRACE {
		ASTExpr* key = (ASTExpr*)$3;
		ASTStmtSwitch* sw = (ASTStmtSwitch*)$6;
		sw->setKey(key);
		$$ = sw;}
	;
SwitchStmt1 : SwitchCases StmtList {
			ASTStmtSwitch* sw = new ASTStmtSwitch(@$);
			ASTSwitchCases* cases = (ASTSwitchCases*)$1;
			ASTBlock* block = (ASTBlock*)$2;
			cases->setBlock(block);
			sw->addCases(cases);
			$$ = sw;}
	| SwitchStmt1 SwitchCases StmtList {
			ASTStmtSwitch* sw = (ASTStmtSwitch*)$1;
			ASTSwitchCases* cases = (ASTSwitchCases*)$2;
			ASTBlock* block = (ASTBlock*)$3;
			cases->setBlock(block);
			sw->addCases(cases);
			$$ = sw;}
	;
SwitchCases : CASE ConstExpr COLON {
			ASTSwitchCases* cases = new ASTSwitchCases(@$);
			ASTExprConst* key = (ASTExprConst*)$2;
			cases->addCase(key);
			$$ = cases;}
	| DEFAULT COLON {
			ASTSwitchCases* cases = new ASTSwitchCases(@$);
			cases->addDefaultCase();
			$$ = cases;}
	| SwitchCases CASE ConstExpr COLON {
			ASTSwitchCases* cases = (ASTSwitchCases*)$1;
			ASTExprConst* key = (ASTExprConst*)$3;
			cases->addCase(key);
			$$ = cases;}
	| SwitchCases DEFAULT COLON {
			ASTSwitchCases* cases = (ASTSwitchCases*)$1;
			cases->addDefaultCase();
			$$ = cases;}
	;


ReturnStmt : RETURN Expr {$$ = new ASTStmtReturnVal((ASTExpr *)$2,@1);}
	| RETURN {$$ = new ASTStmtReturn(@1);}
	;

%%

/*        programs */

void yyerror(const char *s) {
	char temp[512];
    snprintf(temp, 512, "line %d: %s, on token %s", yylineno, s, yytext);
    box_out(temp);
    box_eol();
}

int go(const char *f)
{
yyin = NULL;
resetLexer();
yyin = fopen(f, "r");
if(!yyin)
{
	box_out("Can't open input file");
	box_eol();
	return -1;
}
	curfilename = string(f);
	int result = yyparse();
	fclose(yyin);
	return result;
}

