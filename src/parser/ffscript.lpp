/* -*- mode: bison; tab-width: 8 -*-
  use this file to generate lex.yy.c
  command: flex -B -olex.yy.cpp ffscript.lpp
*/

%option yylineno
%option noyywrap
%option never-interactive
WS	[ \t\n\r]

%x COMMENT
%s HASH

%{
#include <stdlib.h>
#include "AST.h"
#include "../zsyssimple.h"
#include "y.tab.hpp"
YYLTYPE noloc = {0,0,0,0};
void doLines();
%}

%%

script          { doLines(); return TOK_SCRIPT; }
float           { doLines(); return TOK_ZFLOAT; }
int             { doLines(); return TOK_ZFLOAT; }
for             { doLines(); return TOK_FOR; }
bool            { doLines(); return TOK_ZBOOL; }
void            { doLines(); return TOK_ZVOID; }
if              { doLines(); return TOK_IF; }
else            { doLines(); return TOK_ELSE; }
switch          { doLines(); return TOK_SWITCH; }
case            { doLines(); return TOK_CASE; }
default         { doLines(); return TOK_DEFAULT; }
return          { doLines(); return TOK_RETURN; }
import          { doLines(); return TOK_IMPORT; }
true            { doLines(); return TOK_ZTRUE; }
false           { doLines(); return TOK_ZFALSE; }
while           { doLines(); return TOK_WHILE; }
ffc             { doLines(); return TOK_FFC; }
itemdata        { doLines(); return TOK_ITEMCLASS; }
item            { doLines(); return TOK_ITEM; }
global          { doLines(); return TOK_GLOBAL; }
break           { doLines(); return TOK_BREAK; }
continue        { doLines(); return TOK_CONTINUE; }
const           { doLines(); return TOK_ZCONST; }
do              { doLines(); return TOK_DO; }
npc             { doLines(); return TOK_NPC; }
lweapon         { doLines(); return TOK_LWEAPON; }
eweapon         { doLines(); return TOK_EWEAPON; }
typedef         { doLines(); return TOK_TYPEDEF; }
compile_error   { doLines(); return TOK_COMPILEERROR; }
OPTION_VALUE	{ doLines(); return TOK_OPTIONVALUE; }

\-\>    { doLines(); return TOK_ARROW; }
\<\<=   { doLines(); return TOK_LSHIFTASSIGN; }
\>\>=   { doLines(); return TOK_RSHIFTASSIGN; }
\<\<    { doLines(); return TOK_LSHIFT; }
\>\>    { doLines(); return TOK_RSHIFT; }
\<=     { doLines(); return TOK_LE; }
\<      { doLines(); return TOK_LT; }
\>=     { doLines(); return TOK_GE; }
\>      { doLines(); return TOK_GT; }
==      { doLines(); return TOK_EQ; }
\!=     { doLines(); return TOK_NE; }
\=      { doLines(); return TOK_ASSIGN; }
\+=     { doLines(); return TOK_PLUSASSIGN; }
\-=     { doLines(); return TOK_MINUSASSIGN; }
\*=     { doLines(); return TOK_TIMESASSIGN; }
\/=     { doLines(); return TOK_DIVIDEASSIGN; }
\&\&=   { doLines(); return TOK_ANDASSIGN; }
\|\|=   { doLines(); return TOK_ORASSIGN; }
\&=     { doLines(); return TOK_BITANDASSIGN; }
\|=     { doLines(); return TOK_BITORASSIGN; }
\^=     { doLines(); return TOK_BITXORASSIGN; }
\%=     { doLines(); return TOK_MODULOASSIGN; }
\:      { doLines(); return TOK_COLON; }
\;      { doLines(); return TOK_SEMICOLON; }
\,      { doLines(); return TOK_COMMA; }
\[      { doLines(); return TOK_LBRACKET; }
\]      { doLines(); return TOK_RBRACKET; }
\(      { doLines(); return TOK_LPAREN; }
\)      { doLines(); return TOK_RPAREN; }
\+\+    { doLines(); return TOK_INCREMENT; }
\-\-    { doLines(); return TOK_DECREMENT; }
\.      { doLines(); return TOK_DOT; }
\+      { doLines(); return TOK_PLUS; }
\-      { doLines(); return TOK_MINUS; }
\*      { doLines(); return TOK_TIMES; }
\/      { doLines(); return TOK_DIVIDE; }
\{      { doLines(); return TOK_LBRACE; }
\}      { doLines(); return TOK_RBRACE; }
\&\&    { doLines(); return TOK_AND; }
\|\|    { doLines(); return TOK_OR; }
\&      { doLines(); return TOK_BITAND; }
\|      { doLines(); return TOK_BITOR; }
\~      { doLines(); return TOK_BITNOT; }
\^      { doLines(); return TOK_BITXOR; }
\!      { doLines(); return TOK_NOT; }
\%      { doLines(); return TOK_MODULO; }

define                  { doLines(); return TOK_DEFINE; }
"//".*                  { ; }
"/*"                    { doLines(); BEGIN(COMMENT); }
<COMMENT>"*/"           { doLines(); BEGIN(INITIAL); }
<COMMENT>([^*]|\n)+|.   { ; }
<COMMENT><<EOF>>        {
	char temp[512];
	sprintf(temp, "Scanner: Unterminated comment.\n");
	box_out(temp);
	box_eol();
	return 0;
}

<INITIAL>\#		{ doLines(); BEGIN(HASH); return TOK_HASH; }
<HASH>{
	\\\n		{ doLines(); }
	\n		{ doLines(); BEGIN(INITIAL); return TOK_ENDLINE; }
	option		{ doLines(); return TOK_OPTION; }
	inherit		{ doLines(); return TOK_INHERIT; }
	on		{ doLines(); return TOK_ZTRUE; }
	off		{ doLines(); return TOK_ZFALSE; }
}


[_a-zA-Z]([_a-zA-Z]|[0-9])*	{
	doLines();
	yylval = new ASTString(yytext, yylloc);
	return TOK_IDENTIFIER;
}

([0-9]*\.?[0-9]+) {
	doLines();
	yylval = new ASTFloat(yytext, ASTFloat::TYPE_DECIMAL, yylloc);
	return TOK_NUMBER;
}

(0x[0-9a-fA-F]+) {
	doLines();
	yylval = new ASTFloat(yytext, ASTFloat::TYPE_HEX, yylloc);
	return TOK_NUMBER;
}

([0-1]+b) {
	doLines();
	yylval = new ASTFloat(yytext, ASTFloat::TYPE_BINARY, yylloc);
	return TOK_NUMBER;
}

\"[^\"]+\" {
	doLines();
	yylval = new ASTString(yytext, yylloc);
	return TOK_QUOTEDSTRING;
}

\'[^\']?\' {
	doLines();
	yylval = new ASTString(yytext, yylloc);
	return TOK_SINGLECHAR;
}

{WS} { ; }


. {
	char temp[512];
	sprintf(temp, "Scanner, line %d: lexical error '%s'.\n", yylineno, yytext); 
	box_out(temp);
	box_eol();
}

%%

void resetLexer() {
	YY_FLUSH_BUFFER;
	yylineno=1;
}

void doLines()
{
	YYLTYPE rval = {yylineno, 0, yylineno, 0};
	yylloc = rval;
}
 
