/* -*- mode: bison; tab-width: 8 -*-
  use this file to generate lex.yy.c
  command: flex -B -olex.yy.cpp ffscript.lpp
*/

%option noyywrap
%option never-interactive
WS	[ \t\r]

%x COMMENT
%s HASH

%{
#include <stdlib.h>
#include "AST.h"
#include "../zsyssimple.h"
#include "y.tab.hpp"
YYLTYPE noloc = {0,0,0,0};
int yyrow, yycol;

// Defined in ffscript.ypp.
void yymsg(std::string const& message, int row = yyrow, int col = yycol);
%}

%%

 /* Parser local code */
%{
int comment_start_row, comment_start_col;

#define NEWLINE ++yyrow; yycol = 1
#define SKIP yycol += yyleng

#define UPDATE_YYLLOC \
yylloc.first_line = yylloc.last_line = yyrow; \
yylloc.first_column = yycol; \
yycol += yyleng; \
yylloc.last_column = yycol

// Return token.
#define TOKEN(NAME) UPDATE_YYLLOC; return TOK_##NAME

// Return token and value.
#define VALUE(NAME, CONSTRUCTOR) \
UPDATE_YYLLOC; \
yylval = new CONSTRUCTOR; \
return TOK_##NAME

%}

 /* Keywords */
script		TOKEN( SCRIPT );
float		TOKEN( ZFLOAT );
int		TOKEN( ZFLOAT );
for		TOKEN( FOR );
bool		TOKEN( ZBOOL );
void		TOKEN( ZVOID );
if		TOKEN( IF );
else		TOKEN( ELSE );
switch		TOKEN( SWITCH );
case		TOKEN( CASE );
default		TOKEN( DEFAULT );
return		TOKEN( RETURN );
import		TOKEN( IMPORT );
true		TOKEN( ZTRUE );
false		TOKEN( ZFALSE );
while		TOKEN( WHILE );
ffc		TOKEN( FFC );
itemdata	TOKEN( ITEMCLASS );
item		TOKEN( ITEM );
global		TOKEN( GLOBAL );
break		TOKEN( BREAK );
continue	TOKEN( CONTINUE );
const		TOKEN( ZCONST );
do		TOKEN( DO );
npc		TOKEN( NPC );
lweapon		TOKEN( LWEAPON );
eweapon		TOKEN( EWEAPON );
typedef		TOKEN( TYPEDEF );
compile_error	TOKEN( COMPILEERROR );
OPTION_VALUE	TOKEN( OPTIONVALUE );
define		TOKEN( DEFINE );

 /* Syntax */
","		TOKEN( COMMA );
"."		TOKEN( DOT );
";"		TOKEN( SEMICOLON );
":"		TOKEN( COLON );
"("		TOKEN( LPAREN );
")"		TOKEN( RPAREN );
"["		TOKEN( LBRACKET );
"]"		TOKEN( RBRACKET );
"{"		TOKEN( LBRACE );
"}"		TOKEN( RBRACE );

 /* Operators (in order of operations) */
"->"		TOKEN( ARROW );
"++"		TOKEN( INCREMENT );
"--"		TOKEN( DECREMENT );
"!"		TOKEN( NOT );
"~"		TOKEN( BITNOT );
"*"		TOKEN( TIMES );
"/"		TOKEN( DIVIDE );
"%"		TOKEN( MODULO );
"+"		TOKEN( PLUS );
"-"		TOKEN( MINUS );
"<<"		TOKEN( LSHIFT );
">>"		TOKEN( RSHIFT );
"<"		TOKEN( LT );
"<="		TOKEN( LE );
">"		TOKEN( GT );
">="		TOKEN( GE );
"=="		TOKEN( EQ );
"!="		TOKEN( NE );
"&"		TOKEN( BITAND );
"^"		TOKEN( BITXOR );
"|"		TOKEN( BITOR );
"&&"		TOKEN( AND );
"||"		TOKEN( OR );
"="		TOKEN( ASSIGN );
"+="		TOKEN( PLUSASSIGN );
"-="		TOKEN( MINUSASSIGN );
"*="		TOKEN( TIMESASSIGN );
"/="		TOKEN( DIVIDEASSIGN );
"%="		TOKEN( MODULOASSIGN );
"<<="		TOKEN( LSHIFTASSIGN );
">>="		TOKEN( RSHIFTASSIGN );
"&="		TOKEN( BITANDASSIGN );
"^="		TOKEN( BITXORASSIGN );
"|="		TOKEN( BITORASSIGN );
"&&="		TOKEN( ANDASSIGN );
"||="		TOKEN( ORASSIGN );

 /* Line Comments */
"//".*		/* hit end of file */
"//".*\n	NEWLINE;

 /* Block Comments */
"/*"[^*\n]*			{
	comment_start_row = yyrow;
	comment_start_col = yycol;
	SKIP; 
	BEGIN( COMMENT );
}
<COMMENT>{
	[^*\n]*			SKIP;
	[^*\n]*\n		NEWLINE;
	"*"+[^*/\n]*		SKIP;
	"*"+[^*/\n]*\n		NEWLINE;
	"*"+"/"			SKIP; BEGIN( INITIAL );
	<<EOF>>			{
		yymsg("WARNING: Comment does not end.",
		      comment_start_row,
		      comment_start_col);
		return 0;
	}
}

 /* Hash Commands */
<INITIAL>"#"		BEGIN( HASH ); TOKEN( HASH );
<HASH>{
	\\\n		NEWLINE;
	\n		NEWLINE; BEGIN( INITIAL ); TOKEN( ENDLINE );
	option		TOKEN( OPTION );
	inherit		TOKEN( INHERIT );
	on		TOKEN( ZTRUE );
	off		TOKEN( ZFALSE );
}

 /* Identifier */
[_a-zA-Z][_a-zA-Z0-9]*	{
	VALUE( IDENTIFIER, ASTString(yytext, yylloc) );
}

 /* Numbers */
[0-9]*\.?[0-9]+ 	{
	VALUE( NUMBER, ASTFloat(yytext, ASTFloat::TYPE_DECIMAL, yylloc) );
}
0x[0-9a-fA-F]+ 		{
	VALUE( NUMBER, ASTFloat(yytext, ASTFloat::TYPE_HEX, yylloc) );
}
[0-1]+b			{
	VALUE( NUMBER, ASTFloat(yytext, ASTFloat::TYPE_BINARY, yylloc) );
}

 /* String */
\"[^\"]+\" {
	VALUE( QUOTEDSTRING, ASTString(yytext, yylloc) );
}

 /* Char */
\'[^\']?\' {
	VALUE( SINGLECHAR, ASTString(yytext, yylloc) );
}

 /* Whitespace */
[ \t\r]*\n	NEWLINE;
[ \t\r]+	SKIP;

 /* Error */
.		yymsg("WARNING: Unknown Character");

%%

void resetLexer() {
	YY_FLUSH_BUFFER;
	yyrow = 1;
	yycol = 1;
}
